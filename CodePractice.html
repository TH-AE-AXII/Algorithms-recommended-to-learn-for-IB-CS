<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=cGvuclDC_Z1vE_cnVEU6AUimC58BdyKaCqTMUNXl8t1WPqTg08jjjidoWIMcLnDV);ol{margin:0;padding:0}table td,table th{padding:0}.c28{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:539.2pt;border-top-color:#000000;border-bottom-style:solid}.c18{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:540pt;border-top-color:#000000;border-bottom-style:solid}.c46{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:538.5pt;border-top-color:#000000;border-bottom-style:solid}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c36{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c7{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c8{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c24{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c32{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:26pt;font-family:"Arial";font-style:normal}.c27{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c17{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c21{padding-top:0pt;padding-bottom:16pt;line-height:1.15;page-break-after:avoid;text-align:center}.c22{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left;height:11pt}.c33{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;text-align:center}.c40{margin-left:1.5pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c25{text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c4{padding-top:3pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c47{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c31{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c30{margin-left:0.8pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c45{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c14{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c34{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c19{border-spacing:0;border-collapse:collapse;margin-right:auto}.c1{font-family:"Consolas";color:#880000;font-weight:400}.c3{font-family:"Consolas";color:#000088;font-weight:400}.c43{color:#000000;font-weight:400;font-family:"Source Code Pro"}.c0{font-family:"Consolas";color:#006666;font-weight:400}.c38{background-color:#ffffff;max-width:540pt;padding:36pt 36pt 36pt 36pt}.c2{font-family:"Consolas";color:#000000;font-weight:400}.c11{color:inherit;text-decoration:inherit}.c16{orphans:2;widows:2}.c37{color:#000000;text-decoration:none}.c15{font-weight:700;font-family:"Consolas"}.c9{font-weight:400;font-family:"Consolas"}.c35{font-style:italic}.c41{height:20pt}.c44{font-size:16pt}.c23{height:1405pt}.c13{color:#660066}.c39{margin-left:9pt}.c6{height:0pt}.c10{color:#008800}.c26{font-weight:700}.c29{height:11pt}.c42{color:#333333}.c20{margin-left:18pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c38 doc-content"><div><p class="c16 c29 c45"><span class="c12"></span></p></div><h1 class="c17 c16 c41" id="h.3ms6mm8veu13"><span class="c5"></span></h1><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c16 c33 title" id="h.aniqthvu0nit"><span class="c32">IB Problems, Standard Algorithms, and ADT Structure in JAVA</span></p><p class="c7"><span class="c12"></span></p><p class="c16 c21 subtitle" id="h.7yqkzq2qo4sj"><span class="c36">By Thach Dang, IBO Victim of 2024 </span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><h1 class="c17 c16" id="h.hh0c3kz64cru"><span class="c5">Table Of Contents</span></h1><p class="c4"><span class="c8"><a class="c11" href="#h.hh0c3kz64cru">Table Of Contents&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.a0ks1ttz0jv1">Resources:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</a></span></p><p class="c4 c20"><span class="c12"><a class="c11" href="#h.jpnch1n7ngfl">JETS: Java Examination Tool Subset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</a></span></p><p class="c4 c20"><span class="c12"><a class="c11" href="#h.k7kvywtufwzr">IB Pseudocode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</a></span></p><p class="c4 c20"><span class="c12"><a class="c11" href="#h.aw9wtk4h1me6">Pseudocode Coding Bat (very specific, use more as a learning tool)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.3f44ox674wae">1. Array Rotation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.gm8vhvqtz0x5">2. Find Middle Element of a Linked List&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.6a9r6v6cvqvy">3. Implement a Stack&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.qf27qc1vdpg0">4. Implement a Queue Using Two Stacks&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.ucyudquguqu1">5. Check Balanced Parentheses Using Stack&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.nq6huipbs0u5">6. Reverse a Queue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.2iyju7fyyn99">7. Merge Two Sorted Arrays&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.mrl0c53nmpvi">8. Remove Duplicates from a Linked List&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.jwizrsp7wu88">9. Implement a Circular Queue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.nucxxl9j02i3">10. Find Intersection of Two Arrays&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.4d5ui6nx0294">11. Quick Sort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.t0d4eyaz0q">12. Binary Search&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.9f4gan3smpcw">13. Bubble Sort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.wd0y5mnd8m19">14. Selection Sort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.xznqnvjun0wl">15. 2D Arrays&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.8qxsgcnv3nub">16. Rotate NxN 2D Array by k steps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.3n9njig0oo2d">17. Binary Trees&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.7tt7bzoiyl53">18. Inorder Tree Traversal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.4u4yveil1qf3">19. Post Order Traversal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.os0avq8sc62l">20. Preorder Tree Traversal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.dohobu953g0i">21. Linked Lists Operations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16</a></span></p><p class="c4"><span class="c8"><a class="c11" href="#h.fmjrewpx9jva">22. Error Handling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19</a></span></p><p class="c4"><span class="c26 c37"><a class="c11" href="#h.ek5xc7xxlkwj">23. ArrayList Operations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19</a></span></p><h1 class="c17 c16" id="h.a0ks1ttz0jv1"><span class="c5">Resources:</span></h1><h2 class="c16 c27" id="h.jpnch1n7ngfl"><span class="c34"><a class="c11" href="https://www.google.com/url?q=https://drive.google.com/file/d/140_RgYw2nGVJvXp91UgSfkMKvSWFIaob/view?usp%3Ddrive_link&amp;sa=D&amp;source=editors&amp;ust=1731433459292652&amp;usg=AOvVaw0fIE-QR9oifDCQIj5h1lf-">JETS</a></span><span class="c24">: Java Examination Tool Subset</span></h2><h2 class="c27 c16" id="h.k7kvywtufwzr"><span class="c34"><a class="c11" href="https://www.google.com/url?q=https://drive.google.com/file/d/1r6CTsiJ8eXWZzPUebREUHkDDNW6KiFrN/view&amp;sa=D&amp;source=editors&amp;ust=1731433459293008&amp;usg=AOvVaw1rGMm2vU1qt07etT0u8L5f">IB Pseudocode</a></span></h2><h2 class="c27 c16" id="h.aw9wtk4h1me6"><span class="c34"><a class="c11" href="https://www.google.com/url?q=https://graded-cs-resources.github.io/CodingBatPseudo/&amp;sa=D&amp;source=editors&amp;ust=1731433459293243&amp;usg=AOvVaw25dGeeoDfhwgWWBDhdw0iS">Pseudocode Coding Bat</a></span><span class="c24">&nbsp;(very specific, use more as a learning tool)</span></h2><p class="c7"><span class="c12"></span></p><p class="c7"><span class="c12"></span></p><h1 class="c17 c16" id="h.3f44ox674wae"><span class="c5">1. Array Rotation</span></h1><p class="c14 c16"><span>Question: Write </span><span>Java Code</span><span>, </span><span class="c35">Rotate</span><span class="c12">, &nbsp;to rotate an array A of n elements to the right by k steps, where k is a non-negative integer.</span></p><p class="c7"><span class="c12"></span></p><table class="c40"><tr class="c6"><td class="c46" colspan="1" rowspan="1"><p class="c14"><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">rotate(</span><span class="c3">int</span><span class="c9 c13">[] array, </span><span class="c3">int</span><span class="c9 c13">&nbsp;k)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;n = array.length;<br> &nbsp; &nbsp;k = k % n;<br> &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">[] tempArray = </span><span class="c3">new</span><span class="c2">&nbsp;</span><span class="c3">int</span><span class="c2">[n];<br> &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(</span><span class="c3">int</span><span class="c2">&nbsp;i = </span><span class="c0">0</span><span class="c2">; i &lt; n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;newPosition = (i + k) % n;<br> &nbsp; &nbsp; &nbsp; &nbsp;tempArray[newPosition] = array[i];<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(</span><span class="c3">int</span><span class="c2">&nbsp;i = </span><span class="c0">0</span><span class="c2">; i &lt; n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;array[i] = tempArray[i];<br> &nbsp; &nbsp;}<br>}<br></span></p></td></tr></table><h1 class="c17 c16" id="h.gm8vhvqtz0x5"><span class="c5">2. Find Middle Element of a Linked List</span></h1><p class="c14 c16"><span>Question: Write </span><span>Java Code</span><span class="c12">&nbsp;to find the middle element of a singly linked list. If the list has an even number of elements, return the second middle element.</span></p><p class="c7"><span class="c12"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">class</span><span class="c2">&nbsp;</span><span class="c9 c13">ListNode</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;val;<br> &nbsp; &nbsp;ListNode next;<br> &nbsp; &nbsp;ListNode(</span><span class="c3">int</span><span class="c2">&nbsp;x) { val = x; }<br>}<br><br></span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;</span><span class="c9 c13">findMiddleElement(ListNode head)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;ListNode slow = head, fast = head;<br> &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(fast != </span><span class="c3">null</span><span class="c2">&nbsp;&amp;&amp; fast.next != </span><span class="c3">null</span><span class="c2">) {<br> &nbsp; &nbsp; &nbsp; &nbsp;slow = slow.next;<br> &nbsp; &nbsp; &nbsp; &nbsp;fast = fast.next.next;<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;slow.val;<br>}</span></p></td></tr></table><p class="c7"><span class="c12"></span></p><h1 class="c17 c16" id="h.6a9r6v6cvqvy"><span class="c5">3. Implement a Stack</span></h1><p class="c14 c16"><span>Question: Write </span><span>Java Code</span><span class="c12">&nbsp;for implementing a stack with operations push, pop, and peek. Use an array as the underlying data structure.</span></p><p class="c7"><span class="c12"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">class</span><span class="c2">&nbsp;</span><span class="c9 c13">Stack</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c2">&nbsp;</span><span class="c3">int</span><span class="c2">[] data;<br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c2">&nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;top;<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c9 c13">Stack(</span><span class="c3">int</span><span class="c9 c13">&nbsp;size)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;data = </span><span class="c3">new</span><span class="c2">&nbsp;</span><span class="c3">int</span><span class="c2">[size];<br> &nbsp; &nbsp; &nbsp; &nbsp;top = -</span><span class="c0">1</span><span class="c2">;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">push(</span><span class="c3">int</span><span class="c9 c13">&nbsp;element)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;data[++top] = element;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;</span><span class="c9 c13">pop()</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(isEmpty())<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">throw</span><span class="c2">&nbsp;</span><span class="c3">new</span><span class="c2">&nbsp;IllegalStateException(</span><span class="c9 c10">&quot;Stack is empty&quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;data[top--];<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">boolean</span><span class="c2">&nbsp;</span><span class="c9 c13">isEmpty()</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;top == -</span><span class="c0">1</span><span class="c2">;<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><h1 class="c17 c16" id="h.qf27qc1vdpg0"><span class="c5">4. Implement a Queue Using Two Stacks</span></h1><p class="c14 c16"><span>Question: Write </span><span>Java Code</span><span class="c12">&nbsp;to implement a queue using two stacks. The queue should support enqueue and dequeue operations.</span></p><p class="c7"><span class="c12"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">import</span><span class="c2">&nbsp;java.util.Stack;<br><br></span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">class</span><span class="c2">&nbsp;</span><span class="c9 c13">QueueUsingStacks</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c2">&nbsp;Stack&lt;Integer&gt; inStack = </span><span class="c3">new</span><span class="c2">&nbsp;Stack&lt;&gt;();<br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c2">&nbsp;Stack&lt;Integer&gt; outStack = </span><span class="c3">new</span><span class="c2">&nbsp;Stack&lt;&gt;();<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">enqueue(</span><span class="c3">int</span><span class="c9 c13">&nbsp;element)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;inStack.push(element);<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;</span><span class="c9 c13">dequeue()</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(outStack.isEmpty()) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(!inStack.isEmpty()) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;outStack.push(inStack.pop());<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;outStack.pop();<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><h1 class="c17 c16" id="h.ucyudquguqu1"><span class="c5">5. Check Balanced Parentheses Using Stack</span></h1><p class="c14 c16"><span>Question: Write </span><span>Java Code</span><span>&nbsp;method </span><span class="c35">Balanced</span><span class="c12">&nbsp;that uses a stack S to check if an input string P of parentheses (characters &#39;(&#39; and &#39;)&#39;) is balanced. A string is balanced if all opening parentheses have a corresponding closing parenthesis in the correct order. Return true if it is balanced, false otherwise.</span></p><p class="c7"><span class="c12"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">boolean</span><span class="c2">&nbsp;</span><span class="c9 c13">isBalanced(String s)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;Stack&lt;Character&gt; stack = </span><span class="c3">new</span><span class="c2">&nbsp;Stack&lt;&gt;();<br> &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(</span><span class="c3">char</span><span class="c2">&nbsp;c : s.toCharArray()) {<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(c == </span><span class="c9 c10">&#39;(&#39;</span><span class="c2">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stack.push(c);<br> &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">else</span><span class="c2">&nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(c == </span><span class="c9 c10">&#39;)&#39;</span><span class="c2">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(stack.isEmpty()) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;</span><span class="c3">false</span><span class="c2">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stack.pop();<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;stack.isEmpty();<br>}</span></p></td></tr></table><h1 class="c17 c16" id="h.nq6huipbs0u5"><span class="c5">6. Reverse a Queue</span></h1><p class="c14 c16"><span>Question: Write </span><span>Java Code</span><span class="c12">&nbsp;to reverse the elements of a queue using only standard queue operations. You may use a stack as temporary storage. (enqueue, dequeue, and isEmpty).</span></p><p class="c7"><span class="c12"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">import</span><span class="c2">&nbsp;java.util.LinkedList;<br></span><span class="c3">import</span><span class="c2">&nbsp;java.util.Queue;<br></span><span class="c3">import</span><span class="c2">&nbsp;java.util.Stack;<br><br></span><span class="c3">Public</span><span class="c9">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">reverseQueue(Queue&lt;Integer&gt; queue)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;Stack&lt;Integer&gt; stack = </span><span class="c3">new</span><span class="c2">&nbsp;Stack&lt;&gt;();<br> &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(!queue.isEmpty()) {<br> &nbsp; &nbsp; &nbsp; &nbsp;stack.push(queue.poll());<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(!stack.isEmpty()) {<br> &nbsp; &nbsp; &nbsp; &nbsp;queue.offer(stack.pop());<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><h1 class="c17 c16" id="h.2iyju7fyyn99"><span class="c5">7. Merge Two Sorted Arrays</span></h1><p class="c14 c16"><span>Question: Write </span><span>Java Code</span><span class="c12">&nbsp;to merge two sorted arrays of integers, A and B, into a new sorted array C.</span></p><p class="c7"><span class="c12"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">int</span><span class="c2">[] mergeSortedArrays(</span><span class="c3">int</span><span class="c2">[] A, </span><span class="c3">int</span><span class="c2">[] B) {<br> &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">[] C = </span><span class="c3">new</span><span class="c2">&nbsp;</span><span class="c3">int</span><span class="c2">[A.length + B.length];<br> &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;i = </span><span class="c0">0</span><span class="c2">, j = </span><span class="c0">0</span><span class="c2">, k = </span><span class="c0">0</span><span class="c2">;<br> &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(i &lt; A.length &amp;&amp; j &lt; B.length) {<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(A[i] &lt; B[j]) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C[k++] = A[i++];<br> &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">else</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C[k++] = B[j++];<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(i &lt; A.length) {<br> &nbsp; &nbsp; &nbsp; &nbsp;C[k++] = A[i++];<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(j &lt; B.length) {<br> &nbsp; &nbsp; &nbsp; &nbsp;C[k++] = B[j++];<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;C;<br>}</span></p></td></tr></table><h1 class="c17 c16" id="h.mrl0c53nmpvi"><span class="c5">8. Remove Duplicates from a Linked List</span></h1><p class="c14 c16"><span>Question: Write </span><span>Java Code</span><span class="c12">&nbsp;method, RemoveDup, to remove duplicate values from an unsorted linked list. You may use another Queue as temporary storage.</span></p><p class="c7"><span class="c12"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">removeDuplicates(ListNode head)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;Set&lt;Integer&gt; seen = </span><span class="c3">new</span><span class="c2">&nbsp;HashSet&lt;&gt;();<br> &nbsp; &nbsp;ListNode current = head, prev = </span><span class="c3">null</span><span class="c2">;<br> &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(current != </span><span class="c3">null</span><span class="c2">) {<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(!seen.add(current.val)) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;prev.next = current.next;<br> &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">else</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;prev = current;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;current = current.next;<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><h1 class="c17 c16" id="h.jwizrsp7wu88"><span class="c5">9. Implement a Circular Queue</span></h1><p class="c14 c16"><span>Question: Write </span><span>Java Code</span><span class="c12">&nbsp;for implementing a circular queue with operations enqueue, dequeue, and isFull. Use an array as the underlying data structure.</span></p><p class="c7"><span class="c12"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">class</span><span class="c2">&nbsp;</span><span class="c9 c13">CircularQueue</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c2">&nbsp;</span><span class="c3">int</span><span class="c2">[] data;<br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c2">&nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;head = </span><span class="c0">0</span><span class="c2">, tail = </span><span class="c0">0</span><span class="c2">, size = </span><span class="c0">0</span><span class="c2">, capacity;<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c9 c13">CircularQueue(</span><span class="c3">int</span><span class="c9 c13">&nbsp;capacity)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">this</span><span class="c2">.capacity = capacity;<br> &nbsp; &nbsp; &nbsp; &nbsp;data = </span><span class="c3">new</span><span class="c2">&nbsp;</span><span class="c3">int</span><span class="c2">[capacity];<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">boolean</span><span class="c2">&nbsp;</span><span class="c9 c13">enqueue(</span><span class="c3">int</span><span class="c9 c13">&nbsp;element)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(isFull()) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;</span><span class="c3">false</span><span class="c2">;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;data[tail] = element;<br> &nbsp; &nbsp; &nbsp; &nbsp;tail = (tail + </span><span class="c0">1</span><span class="c2">) % capacity;<br> &nbsp; &nbsp; &nbsp; &nbsp;size++;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;</span><span class="c3">true</span><span class="c2">;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;</span><span class="c9 c13">dequeue()</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(isEmpty()) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">throw</span><span class="c2">&nbsp;</span><span class="c3">new</span><span class="c2">&nbsp;IllegalStateException(</span><span class="c9 c10">&quot;Queue is empty&quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;result = data[head];<br> &nbsp; &nbsp; &nbsp; &nbsp;head = (head + </span><span class="c0">1</span><span class="c2">) % capacity;<br> &nbsp; &nbsp; &nbsp; &nbsp;size--;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;result;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">boolean</span><span class="c2">&nbsp;</span><span class="c9 c13">isFull()</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;size == capacity;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">boolean</span><span class="c2">&nbsp;</span><span class="c9 c13">isEmpty()</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;size == </span><span class="c0">0</span><span class="c2">;<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><h1 class="c17 c16" id="h.nucxxl9j02i3"><span class="c5">10. Find Intersection of Two Arrays</span></h1><p class="c14 c16"><span>Question: Write </span><span>Java Code</span><span class="c12">&nbsp;to find the intersection of two arrays A and B, where the intersection is a collection of elements that are common to both arrays. Avoid using built-in collection methods for the intersection.</span></p><p class="c7"><span class="c12"></span></p><p class="c14"><span class="c3">public</span><span class="c9">&nbsp;</span><span class="c3">class</span><span class="c9">&nbsp;</span><span class="c9 c13">ArrayIntersection</span><span class="c9">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c9">&nbsp;</span><span class="c3">int</span><span class="c9">[] findIntersection(</span><span class="c3">int</span><span class="c9">[] A, </span><span class="c3">int</span><span class="c9">[] B) {<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Sort both arrays using QuickSort</span><span class="c9"><br> &nbsp; &nbsp; &nbsp; &nbsp;QuickSort.sort(A);<br> &nbsp; &nbsp; &nbsp; &nbsp;QuickSort.sort(B);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Initialize pointers for both arrays</span><span class="c9"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c9">&nbsp;pointerA = </span><span class="c0">0</span><span class="c9">, pointerB = </span><span class="c0">0</span><span class="c9">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c9">[] temp = </span><span class="c3">new</span><span class="c9">&nbsp;</span><span class="c3">int</span><span class="c9">[Math.min(A.length, B.length)];<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c9">&nbsp;index = </span><span class="c0">0</span><span class="c9">;<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Use two-pointer technique to find common elements</span><span class="c9"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">while</span><span class="c9">&nbsp;(pointerA &lt; A.length &amp;&amp; pointerB &lt; B.length) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c9">&nbsp;(A[pointerA] &lt; B[pointerB]) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pointerA++;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">else</span><span class="c9">&nbsp;</span><span class="c3">if</span><span class="c9">&nbsp;(A[pointerA] &gt; B[pointerB]) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pointerB++;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">else</span><span class="c9">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Found a common element</span><span class="c9"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c9">&nbsp;(index == </span><span class="c0">0</span><span class="c9">&nbsp;|| temp[index - </span><span class="c0">1</span><span class="c9">] != A[pointerA]) { </span><span class="c1">// Check to avoid duplicates</span><span class="c9"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp[index++] = A[pointerA];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pointerA++;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pointerB++;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Copy the found elements to the final result array</span><span class="c9"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c9">[] result = </span><span class="c3">new</span><span class="c9">&nbsp;</span><span class="c3">int</span><span class="c9">[index];<br> &nbsp; &nbsp; &nbsp; &nbsp;System.arraycopy(temp, </span><span class="c0">0</span><span class="c9">, result, </span><span class="c0">0</span><span class="c9">, index);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c9">&nbsp;result;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c9">&nbsp;</span><span class="c3">void</span><span class="c9">&nbsp;</span><span class="c9 c13">main(String[] args)</span><span class="c9">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c9">[] A = {</span><span class="c0">4</span><span class="c9">, </span><span class="c0">9</span><span class="c9">, </span><span class="c0">5</span><span class="c9">, </span><span class="c0">7</span><span class="c9">, </span><span class="c0">5</span><span class="c9">};<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c9">[] B = {</span><span class="c0">9</span><span class="c9">, </span><span class="c0">4</span><span class="c9">, </span><span class="c0">9</span><span class="c9">, </span><span class="c0">8</span><span class="c9">, </span><span class="c0">4</span><span class="c9">, </span><span class="c0">6</span><span class="c9">};<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c9">[] intersection = findIntersection(A, B);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;Intersection of the two arrays is:&quot;</span><span class="c9">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c9">&nbsp;(</span><span class="c3">int</span><span class="c9">&nbsp;num : intersection) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(num + </span><span class="c9 c10">&quot; &quot;</span><span class="c25 c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br>}</span></p><p class="c14 c29"><span class="c25 c2"></span></p><h1 class="c17" id="h.4d5ui6nx0294"><span class="c5">11. Quick Sort</span></h1><p class="c14 c29"><span class="c12"></span></p><table class="c30"><tr class="c23"><td class="c28" colspan="1" rowspan="1"><p class="c14"><span class="c3">public</span><span class="c9">&nbsp;</span><span class="c3">class</span><span class="c9">&nbsp;</span><span class="c9 c13">QuickSort</span><span class="c9">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c9">&nbsp;</span><span class="c3">void</span><span class="c9">&nbsp;</span><span class="c9 c13">sort(</span><span class="c3">int</span><span class="c9 c13">[] array)</span><span class="c9">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;quickSort(array, </span><span class="c0">0</span><span class="c9">, array.length - </span><span class="c0">1</span><span class="c9">);<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c9">&nbsp;</span><span class="c3">void</span><span class="c9">&nbsp;</span><span class="c9 c13">quickSort(</span><span class="c3">int</span><span class="c9 c13">[] array, </span><span class="c3">int</span><span class="c9 c13">&nbsp;low, </span><span class="c3">int</span><span class="c9 c13">&nbsp;high)</span><span class="c9">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c9">&nbsp;(low &lt; high) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c9">&nbsp;partitionIndex = partition(array, low, high);<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;quickSort(array, low, partitionIndex - </span><span class="c0">1</span><span class="c9">); &nbsp;</span><span class="c1">// Recursively sort elements before partition</span><span class="c9"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;quickSort(array, partitionIndex + </span><span class="c0">1</span><span class="c9">, high); </span><span class="c1">// Recursively sort elements after partition</span><span class="c9"><br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c9">&nbsp;</span><span class="c3">int</span><span class="c9">&nbsp;</span><span class="c9 c13">partition(</span><span class="c3">int</span><span class="c9 c13">[] array, </span><span class="c3">int</span><span class="c9 c13">&nbsp;low, </span><span class="c3">int</span><span class="c9 c13">&nbsp;high)</span><span class="c9">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c9">&nbsp;pivot = array[high]; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c9">&nbsp;i = (low - </span><span class="c0">1</span><span class="c9">); </span><span class="c1">// Index of smaller element</span><span class="c9"><br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c9">&nbsp;(</span><span class="c3">int</span><span class="c9">&nbsp;j = low; j &lt; high; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// If current element is smaller than or equal to pivot</span><span class="c9"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c9">&nbsp;(array[j] &lt;= pivot) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;i++;<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Swap array[i] and array[j]</span><span class="c9"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c9">&nbsp;temp = array[i];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;array[i] = array[j];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;array[j] = temp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Swap array[i+1] and array[high] (or pivot)</span><span class="c9"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c9">&nbsp;temp = array[i + </span><span class="c0">1</span><span class="c9">];<br> &nbsp; &nbsp; &nbsp; &nbsp;array[i + </span><span class="c0">1</span><span class="c9">] = array[high];<br> &nbsp; &nbsp; &nbsp; &nbsp;array[high] = temp;<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c9">&nbsp;i + </span><span class="c0">1</span><span class="c9">;<br> &nbsp; &nbsp;}<br>}<br><br></span></p><h1 class="c17" id="h.t0d4eyaz0q"><span class="c5">12. Binary Search</span></h1><p class="c31 c16"><span class="c12">Question: Write Java Code for Binary Search</span></p></td></tr></table><p class="c7"><span class="c12"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c1">&nbsp; &nbsp; // Performs binary search on a sorted array to find the index of a target value.</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c1">// @param array The sorted array.</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c1">// @param target The value to search for.</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c1">// @return The index of the target if found, otherwise -1.</span><span class="c2"><br> &nbsp; &nbsp; <br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;</span><span class="c9 c13">search(</span><span class="c3">int</span><span class="c9 c13">[] array, </span><span class="c3">int</span><span class="c9 c13">&nbsp;target)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;left = </span><span class="c0">0</span><span class="c2">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;right = array.length - </span><span class="c0">1</span><span class="c2">;<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(left &lt;= right) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;mid = left + (right - left) / </span><span class="c0">2</span><span class="c2">;<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(array[mid] == target) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;mid; </span><span class="c1">// Target found</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">else</span><span class="c2">&nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(array[mid] &lt; target) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;left = mid + </span><span class="c0">1</span><span class="c2">; </span><span class="c1">// Continue search in the right half</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">else</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;right = mid - </span><span class="c0">1</span><span class="c2">; </span><span class="c1">// Continue search in the left half</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;-</span><span class="c0">1</span><span class="c2">; </span><span class="c1">// Target not found</span><span class="c2"><br> &nbsp; &nbsp;}</span></p></td></tr><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14 c29"><span class="c25 c1"></span></p></td></tr></table><h1 class="c17 c16" id="h.9f4gan3smpcw"><span class="c5">13. Bubble Sort</span></h1><p class="c16 c31"><span class="c12">Question: Write Java Code for Bubble Sort</span></p><p class="c16 c22"><span class="c12"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c1">// Sorts an array using the bubble sort algorithm.</span><span class="c2"><br></span><span class="c1">// @param array The array to be sorted.</span></p><p class="c14"><span class="c2"><br></span><span class="c3">public</span><span class="c9">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">sort(</span><span class="c3">int</span><span class="c9 c13">[] array)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">boolean</span><span class="c2">&nbsp;swapped;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;n = array.length;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">do</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;swapped = </span><span class="c3">false</span><span class="c2">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(</span><span class="c3">int</span><span class="c2">&nbsp;i = </span><span class="c0">1</span><span class="c2">; i &lt; n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(array[i - </span><span class="c0">1</span><span class="c2">] &gt; array[i]) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Swap elements at index i-1 and i</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;temp = array[i - </span><span class="c0">1</span><span class="c2">];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;array[i - </span><span class="c0">1</span><span class="c2">] = array[i];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;array[i] = temp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;swapped = </span><span class="c3">true</span><span class="c2">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n--; </span><span class="c1">// Decrement n since the last element is now sorted</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">while</span><span class="c2">&nbsp;(swapped);<br> &nbsp; &nbsp;}</span></p></td></tr><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14 c29"><span class="c25 c1"></span></p></td></tr></table><h1 class="c17 c16" id="h.wd0y5mnd8m19"><span class="c5">14. Selection Sort</span></h1><p class="c14 c16"><span class="c12">Question: Write Java Code for Selection Sort</span></p><p class="c7"><span class="c12"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c1">// Sorts an array using the selection sort algorithm.<br>// </span><span class="c15 c13">@param</span><span class="c1">&nbsp;array The array to be sorted.<br> </span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">sort(</span><span class="c3">int</span><span class="c9 c13">[] array)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;n = array.length;<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(</span><span class="c3">int</span><span class="c2">&nbsp;i = </span><span class="c0">0</span><span class="c2">; i &lt; n - </span><span class="c0">1</span><span class="c2">; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Find the minimum element in the unsorted part of the array</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;minIndex = i;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(</span><span class="c3">int</span><span class="c2">&nbsp;j = i + </span><span class="c0">1</span><span class="c2">; j &lt; n; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(array[j] &lt; array[minIndex]) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;minIndex = j;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Swap the found minimum element with the first element of the unsorted part</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;temp = array[minIndex];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;array[minIndex] = array[i];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;array[i] = temp;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}</span></p></td></tr></table><h1 class="c17 c16" id="h.xznqnvjun0wl"><span class="c5">15. 2D Arrays</span></h1><p class="c7 c39"><span class="c25 c43"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">class</span><span class="c2">&nbsp;</span><span class="c9 c13">Array2DAccess</span><span class="c2">&nbsp;{<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">main(String[] args)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// 1. Creating and initializing a 2D array</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">[][] matrix = {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</span><span class="c0">1</span><span class="c2">, </span><span class="c0">2</span><span class="c2">, </span><span class="c0">3</span><span class="c2">},<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</span><span class="c0">4</span><span class="c2">, </span><span class="c0">5</span><span class="c2">, </span><span class="c0">6</span><span class="c2">},<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</span><span class="c0">7</span><span class="c2">, </span><span class="c0">8</span><span class="c2">, </span><span class="c0">9</span><span class="c2">}<br> &nbsp; &nbsp; &nbsp; &nbsp;};<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// 2. Accessing elements</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;element = matrix[</span><span class="c0">1</span><span class="c2">][</span><span class="c0">2</span><span class="c2">]; </span><span class="c1">// Access element at second row and third column (6)</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;Accessed element: &quot;</span><span class="c2">&nbsp;+ element);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// 3. Modifying elements</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;matrix[</span><span class="c0">2</span><span class="c2">][</span><span class="c0">0</span><span class="c2">] = </span><span class="c0">10</span><span class="c2">; </span><span class="c1">// Change element at third row and first column from 7 to 10</span><span class="c2"><br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// 4. Printing all elements using nested loops</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;Updated matrix:&quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;printMatrix(matrix);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// 5. Using enhanced for loop to iterate over 2D array</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;Iterating with enhanced for-loop:&quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;printMatrixWithEnhancedFor(matrix);<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">printMatrix(</span><span class="c3">int</span><span class="c9 c13">[][] matrix)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(</span><span class="c3">int</span><span class="c2">&nbsp;i = </span><span class="c0">0</span><span class="c2">; i &lt; matrix.length; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(</span><span class="c3">int</span><span class="c2">&nbsp;j = </span><span class="c0">0</span><span class="c2">; j &lt; matrix[i].length; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(matrix[i][j] + </span><span class="c9 c10">&quot; &quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println();<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">printMatrixWithEnhancedFor(</span><span class="c3">int</span><span class="c9 c13">[][] matrix)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(</span><span class="c3">int</span><span class="c2">[] row : matrix) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(</span><span class="c3">int</span><span class="c2">&nbsp;element : row) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(element + </span><span class="c9 c10">&quot; &quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println();<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c7"><span class="c12"></span></p><h1 class="c17 c16" id="h.8qxsgcnv3nub"><span class="c5">16. Rotate NxN 2D Array by k steps</span></h1><p class="c7"><span class="c12"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">class</span><span class="c2">&nbsp;</span><span class="c9 c13">MatrixRotation</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">rotateMatrix(</span><span class="c3">int</span><span class="c9 c13">[][] matrix, </span><span class="c3">int</span><span class="c9 c13">&nbsp;k)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;n = matrix.length;<br> &nbsp; &nbsp; &nbsp; &nbsp;k = k % </span><span class="c0">4</span><span class="c2">; &nbsp;</span><span class="c1">// Only need to consider rotations that are not full circles</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(</span><span class="c3">int</span><span class="c2">&nbsp;r = </span><span class="c0">0</span><span class="c2">; r &lt; k; r++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Perform a single 90-degree rotation clockwise</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(</span><span class="c3">int</span><span class="c2">&nbsp;i = </span><span class="c0">0</span><span class="c2">; i &lt; n / </span><span class="c0">2</span><span class="c2">; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(</span><span class="c3">int</span><span class="c2">&nbsp;j = i; j &lt; n - i - </span><span class="c0">1</span><span class="c2">; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;temp = matrix[i][j];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;matrix[i][j] = matrix[n - </span><span class="c0">1</span><span class="c2">&nbsp;- j][i];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;matrix[n - </span><span class="c0">1</span><span class="c2">&nbsp;- j][i] = matrix[n - </span><span class="c0">1</span><span class="c2">&nbsp;- i][n - </span><span class="c0">1</span><span class="c2">&nbsp;- j];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;matrix[n - </span><span class="c0">1</span><span class="c2">&nbsp;- i][n - </span><span class="c0">1</span><span class="c2">&nbsp;- j] = matrix[j][n - </span><span class="c0">1</span><span class="c2">&nbsp;- i];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;matrix[j][n - </span><span class="c0">1</span><span class="c2">&nbsp;- i] = temp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">printMatrix(</span><span class="c3">int</span><span class="c9 c13">[][] matrix)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(</span><span class="c3">int</span><span class="c2">[] row : matrix) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(</span><span class="c3">int</span><span class="c2">&nbsp;val : row) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(val + </span><span class="c9 c10">&quot; &quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println();<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">main(String[] args)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">[][] matrix = { <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</span><span class="c0">1</span><span class="c2">, </span><span class="c0">2</span><span class="c2">, </span><span class="c0">3</span><span class="c2">}, <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</span><span class="c0">4</span><span class="c2">, </span><span class="c0">5</span><span class="c2">, </span><span class="c0">6</span><span class="c2">}, <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</span><span class="c0">7</span><span class="c2">, </span><span class="c0">8</span><span class="c2">, </span><span class="c0">9</span><span class="c2">} <br> &nbsp; &nbsp; &nbsp; &nbsp;};<br> &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;k = </span><span class="c0">1</span><span class="c2">; &nbsp;</span><span class="c1">// Number of 90-degree clockwise rotations</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;rotateMatrix(matrix, k);<br> &nbsp; &nbsp; &nbsp; &nbsp;printMatrix(matrix);<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c7"><span class="c12"></span></p><h1 class="c17 c16" id="h.3n9njig0oo2d"><span class="c5">17. Binary Trees</span></h1><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">public class</span><span class="c2">&nbsp;</span><span class="c9 c13">TreeNode</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;value;<br> &nbsp; &nbsp;TreeNode left;<br> &nbsp; &nbsp;TreeNode right;<br><br> &nbsp; &nbsp;TreeNode(</span><span class="c3">int</span><span class="c2">&nbsp;value) {<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">this</span><span class="c2">.value = value;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">this</span><span class="c2">.left = </span><span class="c3">null</span><span class="c2">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">this</span><span class="c2">.right = </span><span class="c3">null</span><span class="c2">;<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c14 c29"><span class="c12"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">class</span><span class="c2">&nbsp;</span><span class="c9 c13">BinaryTree</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c1">// Method to perform recursive inorder traversal</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">inorderTraversal(TreeNode root)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(root == </span><span class="c3">null</span><span class="c2">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;inorderTraversal(root.left); &nbsp; &nbsp; &nbsp; </span><span class="c1">// Visit left subtree</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(root.value + </span><span class="c9 c10">&quot; &quot;</span><span class="c2">); </span><span class="c1">// Visit node itself</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;inorderTraversal(root.right); &nbsp; &nbsp; &nbsp;</span><span class="c1">// Visit right subtree</span><span class="c2"><br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">main(String[] args)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Creating a simple binary tree</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;TreeNode root = </span><span class="c3">new</span><span class="c2">&nbsp;TreeNode(</span><span class="c0">1</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;root.left = </span><span class="c3">new</span><span class="c2">&nbsp;TreeNode(</span><span class="c0">2</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;root.right = </span><span class="c3">new</span><span class="c2">&nbsp;TreeNode(</span><span class="c0">3</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;root.left.left = </span><span class="c3">new</span><span class="c2">&nbsp;TreeNode(</span><span class="c0">4</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;root.left.right = </span><span class="c3">new</span><span class="c2">&nbsp;TreeNode(</span><span class="c0">5</span><span class="c2">);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;BinaryTree tree = </span><span class="c3">new</span><span class="c2">&nbsp;BinaryTree();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;Inorder Traversal:&quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;tree.inorderTraversal(root);<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c7"><span class="c12"></span></p><h1 class="c17 c16" id="h.7tt7bzoiyl53"><span class="c5">18. Inorder Tree Traversal </span></h1><p class="c7"><span class="c12"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">import</span><span class="c2">&nbsp;java.util.Stack;<br><br></span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">inorderTraversalIterative(TreeNode root)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(root == </span><span class="c3">null</span><span class="c2">) </span><span class="c3">return</span><span class="c2">;<br><br> &nbsp; &nbsp;Stack&lt;TreeNode&gt; stack = </span><span class="c3">new</span><span class="c2">&nbsp;Stack&lt;&gt;();<br> &nbsp; &nbsp;TreeNode current = root;<br><br> &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(current != </span><span class="c3">null</span><span class="c2">&nbsp;|| !stack.isEmpty()) {<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Reach the left most Node of the current Node</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(current != </span><span class="c3">null</span><span class="c2">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stack.push(current);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;current = current.left;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Current must be null at this point</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;current = stack.pop();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(current.value + </span><span class="c9 c10">&quot; &quot;</span><span class="c2">); </span><span class="c1">// Visit the node</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;current = current.right; </span><span class="c1">// Move to the right subtree</span><span class="c2"><br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c7"><span class="c12"></span></p><h1 class="c17 c16" id="h.4u4yveil1qf3"><span class="c5">19. Post Order Traversal </span></h1><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">import</span><span class="c2">&nbsp;java.util.Stack;<br><br></span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">postorderTraversalIterative(TreeNode root)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(root == </span><span class="c3">null</span><span class="c2">) </span><span class="c3">return</span><span class="c2">;<br><br> &nbsp; &nbsp;Stack&lt;TreeNode&gt; stack1 = </span><span class="c3">new</span><span class="c2">&nbsp;Stack&lt;&gt;();<br> &nbsp; &nbsp;Stack&lt;TreeNode&gt; stack2 = </span><span class="c3">new</span><span class="c2">&nbsp;Stack&lt;&gt;();<br> &nbsp; &nbsp;stack1.push(root);<br><br> &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(!stack1.isEmpty()) {<br> &nbsp; &nbsp; &nbsp; &nbsp;TreeNode currentNode = stack1.pop();<br> &nbsp; &nbsp; &nbsp; &nbsp;stack2.push(currentNode);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(currentNode.left != </span><span class="c3">null</span><span class="c2">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stack1.push(currentNode.left);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(currentNode.right != </span><span class="c3">null</span><span class="c2">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stack1.push(currentNode.right);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(!stack2.isEmpty()) {<br> &nbsp; &nbsp; &nbsp; &nbsp;TreeNode node = stack2.pop();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(node.value + </span><span class="c9 c10">&quot; &quot;</span><span class="c25 c2">);<br> &nbsp; &nbsp;}<br>}</span></p><h1 class="c17" id="h.os0avq8sc62l"><span>20</span><span class="c5">. Preorder Tree Traversal</span></h1></td></tr></table><p class="c14 c29"><span class="c12"></span></p><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">import </span><span class="c2">java.util.Stack;<br><br></span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">preorderTraversalIterative(TreeNode root)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(root == </span><span class="c3">null</span><span class="c2">) </span><span class="c3">return</span><span class="c2">;<br><br> &nbsp; &nbsp;Stack&lt;TreeNode&gt; stack = </span><span class="c3">new</span><span class="c2">&nbsp;Stack&lt;&gt;();<br> &nbsp; &nbsp;stack.push(root);<br><br> &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(!stack.isEmpty()) {<br> &nbsp; &nbsp; &nbsp; &nbsp;TreeNode currentNode = stack.pop();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(currentNode.value + </span><span class="c9 c10">&quot; &quot;</span><span class="c2">); </span><span class="c1">// Visit the node</span><span class="c2"><br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Push right child first so that left child is processed first</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(currentNode.right != </span><span class="c3">null</span><span class="c2">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stack.push(currentNode.right);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(currentNode.left != </span><span class="c3">null</span><span class="c2">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stack.push(currentNode.left);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c14 c29"><span class="c12"></span></p><h1 class="c17" id="h.dohobu953g0i"><span class="c5">21. Linked Lists Operations</span></h1><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">class</span><span class="c2">&nbsp;</span><span class="c9 c13">Node</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;data;<br> &nbsp; &nbsp;Node next;<br><br> &nbsp; &nbsp;Node(</span><span class="c3">int</span><span class="c2">&nbsp;data) {<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">this</span><span class="c2">.data = data;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">this</span><span class="c2">.next = </span><span class="c3">null</span><span class="c2">;<br> &nbsp; &nbsp;}<br>}<br><br></span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">class</span><span class="c2">&nbsp;</span><span class="c9 c13">LinkedList</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;Node head; </span><span class="c1">// head of the list</span><span class="c2"><br><br> &nbsp; &nbsp;</span><span class="c1">// Method to insert a new node at the front of the list</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">insertAtFront(</span><span class="c3">int</span><span class="c9 c13">&nbsp;data)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Node newNode = </span><span class="c3">new</span><span class="c2">&nbsp;Node(data);<br> &nbsp; &nbsp; &nbsp; &nbsp;newNode.next = head;<br> &nbsp; &nbsp; &nbsp; &nbsp;head = newNode;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c1">// Method to insert a new node at the end of the list</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">insertAtEnd(</span><span class="c3">int</span><span class="c9 c13">&nbsp;data)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Node newNode = </span><span class="c3">new</span><span class="c2">&nbsp;Node(data);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(head == </span><span class="c3">null</span><span class="c2">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;head = newNode;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;Node last = head;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(last.next != </span><span class="c3">null</span><span class="c2">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;last = last.next;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;last.next = newNode;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c1">// Method to delete a node by key</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">deleteByKey(</span><span class="c3">int</span><span class="c9 c13">&nbsp;key)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Node temp = head, prev = </span><span class="c3">null</span><span class="c2">;<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// If head node itself holds the key to be deleted</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(temp != </span><span class="c3">null</span><span class="c2">&nbsp;&amp;&amp; temp.data == key) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;head = temp.next; </span><span class="c1">// Changed head</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Search for the key to be deleted, keep track of the previous node</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(temp != </span><span class="c3">null</span><span class="c2">&nbsp;&amp;&amp; temp.data != key) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;prev = temp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp = temp.next;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// If key was not present in linked list</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(temp == </span><span class="c3">null</span><span class="c2">) </span><span class="c3">return</span><span class="c2">;<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Unlink the node from linked list</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;prev.next = temp.next;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c1">// Method to print the linked list</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">printList()</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Node tNode = head;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">while</span><span class="c2">&nbsp;(tNode != </span><span class="c3">null</span><span class="c2">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(tNode.data + </span><span class="c9 c10">&quot; -&gt; &quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tNode = tNode.next;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;NULL&quot;</span><span class="c2">);<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">main(String[] args)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;LinkedList list = </span><span class="c3">new</span><span class="c2">&nbsp;LinkedList();<br><br> &nbsp; &nbsp; &nbsp; &nbsp;list.insertAtEnd(</span><span class="c0">1</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;list.insertAtEnd(</span><span class="c0">2</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;list.insertAtEnd(</span><span class="c0">3</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;list.insertAtFront(</span><span class="c0">0</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;list.insertAtFront(-</span><span class="c0">1</span><span class="c2">);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;Created Linked list is:&quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;list.printList();<br><br> &nbsp; &nbsp; &nbsp; &nbsp;list.deleteByKey(</span><span class="c0">1</span><span class="c2">);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;Linked List after Deletion of 1:&quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;list.printList();<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><h1 class="c16 c17" id="h.fmjrewpx9jva"><span class="c5">22. Error Handling</span></h1><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">class</span><span class="c2">&nbsp;</span><span class="c9 c13">ExceptionHandlingDemo</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">static</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">main(String[] args)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">try</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">[] numbers = {</span><span class="c0">1</span><span class="c2">, </span><span class="c0">2</span><span class="c2">, </span><span class="c0">3</span><span class="c2">};<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// This will throw an ArrayIndexOutOfBoundsException</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(numbers[</span><span class="c0">10</span><span class="c2">]);<br> &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">catch</span><span class="c2">&nbsp;(ArrayIndexOutOfBoundsException e) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;An exception occurred: &quot;</span><span class="c2">&nbsp;+ e.getMessage());<br> &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">finally</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;The &#39;try catch&#39; is finished.&quot;</span><span class="c25 c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br>}</span></p><p class="c14 c29"><span class="c25 c2"></span></p></td></tr></table><p class="c14 c16"><span class="c44">Explanation</span><span class="c12">:</span></p><p class="c14 c16"><span class="c15">ArithmeticException</span><span class="c26">&nbsp;catch block</span><span class="c12">: Specifically handles division by zero.</span></p><p class="c14 c16"><span class="c15">ArrayIndexOutOfBoundsException</span><span>&nbsp;</span><span class="c26">catch block</span><span class="c12">: Specifically handles errors related to array indexing.</span></p><p class="c14 c16"><span class="c15">Exception</span><span>&nbsp;</span><span class="c26">catch block</span><span class="c12">: A general catch block that can handle any exception not caught by the preceding specific blocks.</span></p><p class="c14 c16"><span class="c15">finally</span><span>&nbsp;</span><span class="c26">block</span><span class="c12">: Executes after the try-catch blocks regardless of whether an exception occurred.</span></p><p class="c7"><span class="c12"></span></p><h1 class="c17 c16" id="h.ek5xc7xxlkwj"><span class="c5">23. ArrayList Operations </span></h1><table class="c19"><tr class="c6"><td class="c18" colspan="1" rowspan="1"><p class="c14"><span class="c3">import</span><span class="c2">&nbsp;java.util.ArrayList;<br></span><span class="c3">import</span><span class="c2">&nbsp;java.util.List;<br><br></span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">class</span><span class="c2">&nbsp;</span><span class="c9 c13">ArrayListOperations</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">static</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c9 c13">main(String[] args)</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Create an ArrayList to store Integer elements</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;List&lt;Integer&gt; numbers = </span><span class="c3">new</span><span class="c2">&nbsp;ArrayList&lt;&gt;();<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Adding elements</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;numbers.add(</span><span class="c0">10</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;numbers.add(</span><span class="c0">20</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;numbers.add(</span><span class="c0">30</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;Initial ArrayList: &quot;</span><span class="c2">&nbsp;+ numbers);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Accessing elements</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;Element at index 1: &quot;</span><span class="c2">&nbsp;+ numbers.get(</span><span class="c0">1</span><span class="c2">));<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Adding an element at a specific index</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;numbers.add(</span><span class="c0">1</span><span class="c2">, </span><span class="c0">15</span><span class="c2">); &nbsp;</span><span class="c1">// Insert 15 at index 1</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;ArrayList after adding an element at index 1: &quot;</span><span class="c2">&nbsp;+ numbers);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Removing elements</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;numbers.remove(Integer.valueOf(</span><span class="c0">20</span><span class="c2">)); &nbsp;</span><span class="c1">// Remove element 20</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;ArrayList after removing the element 20: &quot;</span><span class="c2">&nbsp;+ numbers);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;numbers.remove(</span><span class="c0">2</span><span class="c2">); &nbsp;</span><span class="c1">// Remove element at index 2 (30 in this case)</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;ArrayList after removing element at index 2: &quot;</span><span class="c2">&nbsp;+ numbers);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Iterating over ArrayList using for-each loop</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(</span><span class="c9 c10">&quot;Current ArrayList: &quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c2">&nbsp;(Integer number : numbers) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(number + </span><span class="c9 c10">&quot; &quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println();<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Checking if ArrayList is empty</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(numbers.isEmpty()) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;ArrayList is empty&quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">else</span><span class="c2">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;ArrayList is not empty&quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Finding the size of the ArrayList</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;Size of ArrayList: &quot;</span><span class="c2">&nbsp;+ numbers.size());<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">// Clear all elements from ArrayList</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;numbers.clear();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c9 c10">&quot;ArrayList after clear operation: &quot;</span><span class="c2">&nbsp;+ numbers);<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c7"><span class="c12"></span></p><div><p class="c16 c29 c47"><span class="c12"></span></p></div></body></html>